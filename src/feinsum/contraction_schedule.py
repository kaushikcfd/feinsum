"""
.. currentmodule:: feinsum.contraction_schedule

.. autoclass:: Argument
.. autoclass:: EinsumOperand
.. autoclass:: IntermediateResult
.. autoclass:: ContractionSchedule


Helper routines
^^^^^^^^^^^^^^^

.. autofunction:: get_trivial_contraction_schedule
.. autofunction:: get_opt_einsum_contraction_schedule
"""

from __future__ import annotations

from dataclasses import dataclass
from typing import Any

from pytools import UniqueNameGenerator

from feinsum.einsum import BatchedEinsum, SizeParam


class Argument:
    """
    An abstract class denoting an argument to an einsum in
    :class:`ContractionSchedule`. See :attr:`ContractionSchedule.arguments`.
    """

    def __init__(self) -> None:
        if type(self) is Argument:
            raise TypeError(
                "Argument is abstract and cannot be instantiated directly."
            )


@dataclass(frozen=True)
class IntermediateResult(Argument):
    """
    An :class:`Argument` representing an intermediate result available during
    the current contraction.
    """

    name: str


@dataclass(frozen=True, eq=True, repr=True)
class EinsumOperand(Argument):
    """
    An :class:`Argument` representing the *ioperand*-th argument that was
    passed to the parent einsum whose :class:`ContractionSchedule` is being
    specified.
    """

    ioperand: int


@dataclass(frozen=True, eq=True, repr=True)
class ContractionSchedule:
    """
    Records the schedule in which contractions are to be performed in an einsum
    as a series of einsums with the i-th einsum having subscript
    ``subscript[i]`` operating on ``arguments[i]`` and writing its result to
    ``result_names[i]``.

    .. attribute:: result_names

        Names of the result generated by each step.

    .. attribute:: arguments

       A :class:`tuple` containing :class:`tuple` of :class:`str` for each
       contraction in the schedule.

    .. attribute:: nsteps
    """

    subscripts: tuple[str, ...]
    result_names: tuple[str, ...]
    arguments: tuple[tuple[Argument, ...], ...]

    def __post_init__(self) -> None:
        assert len(self.subscripts) == len(self.result_names) == len(self.arguments)

    @property
    def nsteps(self) -> int:
        """
        Returns the number of steps involved in scheduling the einsum.
        """
        return len(self.subscripts)

    def copy(self, **kwargs: Any) -> ContractionSchedule:
        from dataclasses import replace

        return replace(self, **kwargs)


def get_trivial_contraction_schedule(einsum: BatchedEinsum) -> ContractionSchedule:
    """
    Returns the :class:`ContractionSchedule` for *einsum* scheduled as a single
    contraction.
    """
    return ContractionSchedule(
        (einsum.get_subscripts(),),
        ("_fe_out",),
        (tuple(EinsumOperand(i) for i in range(einsum.n)),),
    )


def get_opt_einsum_contraction_schedule(
    expr: BatchedEinsum,
    **opt_einsum_kwargs: Any,
) -> ContractionSchedule:
    """
    Returns a :class:`ContractionSchedule` as computed by
    :func:`opt_einsum.contract_path`.

    :param opt_einsum_kwargs: kwargs to be passed to
        :func:`opt_einsum.contract_path`.

    .. note::

        The following defaults are populated in *opt_einsum_kwargs*, if left
        unspecified:

        - ``optimize="optimal"``
        - ``use_blas=False``
    """
    import opt_einsum

    long_dim_length = opt_einsum_kwargs.pop("long_dim_length", 1_000_000)

    if "optimize" not in opt_einsum_kwargs:
        opt_einsum_kwargs["optimize"] = "optimal"

    if "use_blas" not in opt_einsum_kwargs:
        opt_einsum_kwargs["use_blas"] = False

    _, path = opt_einsum.contract_path(
        expr.get_subscripts(),
        *[
            arg.copy(
                shape=tuple(
                    long_dim_length if isinstance(dim, SizeParam) else dim
                    for dim in arg.shape
                )
            )
            for arg in expr.args[0]
        ],
        **opt_einsum_kwargs,
    )

    current_args: list[Argument] = [
        EinsumOperand(i) for i in range(path.input_subscripts.count(",") + 1)
    ]
    vng = UniqueNameGenerator()

    subscripts: list[str] = []
    result_names: list[str] = []
    arguments: list[tuple[Argument, ...]] = []
    for contraction in path.contraction_list:
        arg_indices, _, subscript, _, _ = contraction
        arguments.append(tuple(current_args[idx] for idx in arg_indices))
        subscripts.append(subscript)
        result_names.append(vng("_fe_tmp"))
        current_args = [
            arg for idx, arg in enumerate(current_args) if idx not in arg_indices
        ] + [IntermediateResult(result_names[-1])]

    assert len(current_args) == 1
    result_names[-1] = vng("_fe_out")

    return ContractionSchedule(
        tuple(subscripts), tuple(result_names), tuple(arguments)
    )
